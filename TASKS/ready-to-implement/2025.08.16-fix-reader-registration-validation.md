## Fix Reader Registration Validation in Lending/Return Commands
- **Created**: 2025-08-16 02:20
- **Priority**: Medium
- **Objective**: Add reader registration validation to prevent orphaned lending data

## 🎯 Core Issue:
- `LendBookCopyToReader` and `ReturnBookCopyFromReader` don't validate reader registration
- Can lead to orphaned lending data (books lent to non-existent/cancelled readers)
- Current cleanup tool found ~6,474 orphaned lendings from this issue

## 📋 Proposed Solution:
- **LendBook**: Strict validation (reader must be currently registered)
- **ReturnBook**: Flexible validation (reader must have been registered sometime, allows cleanup)
- **Event sourced approach**: Use event history in `Decide()` functions (no external queries needed)

## 🔧 Implementation Strategy:
- Add reader event processing to both decide functions
- **LendBook**: Check for `ReaderRegistered` without subsequent `ReaderContractCanceled`
- **ReturnBook**: Check for any `ReaderRegistered` event (ignore cancellation status)
- **BuildEventFilter**: Add `ReaderRegistered` and `ReaderContractCanceled` event types to existing filters

## 📁 Files to Modify:
- `/example/features/lendbookcopytoreader/decide.go` - Add reader validation + update BuildEventFilter
- `/example/features/returnbookcopyfromreader/decide.go` - Add reader validation + update BuildEventFilter

## 💡 Implementation Example:
```go
// 1. Add reader fields to state struct
type state struct {
    // existing fields...
    readerIsRegistered bool
    readerIsCancelled  bool
}

// 2. Update project() method to handle reader events
func project(history core.DomainEvents, bookID string, readerID string) state {
    s := state{
        // existing defaults...
        readerIsRegistered: false,
        readerIsCancelled:  false,
    }

    for _, event := range history {
        switch e := event.(type) {
        // existing cases...
        case core.ReaderRegistered:
            if e.ReaderID == readerID {
                s.readerIsRegistered = true
            }
        case core.ReaderContractCanceled:
            if e.ReaderID == readerID {
                s.readerIsCancelled = true
            }
        }
    }
    return s
}

// 3. Add validation in Decide() function
func Decide(history core.DomainEvents, command Command) DecisionResult {
    s := project(history, command.BookID.String(), command.ReaderID.String())
    
    // LendBook: Strict validation
    if !s.readerIsRegistered || s.readerIsCancelled {
        return decideFailed("reader is not currently registered")
    }
    
    // ReturnBook: Flexible validation  
    if !s.readerIsRegistered {
        return decideFailed("reader was never registered")
    }
    
    // existing business logic...
}

// 4. Update BuildEventFilter to include reader events
func BuildEventFilter(bookID uuid.UUID, readerID uuid.UUID) eventstore.Filter {
    return eventstore.BuildEventFilter().
        Matching().
        AnyEventTypeOf(
            // existing event types...
            core.ReaderRegisteredEventType,
            core.ReaderContractCanceledEventType,
        ).
        AndAnyPredicateOf(
            eventstore.P("BookID", bookID.String()),
            eventstore.P("ReaderID", readerID.String()),
        ).
        Finalize()
}
```

## 🎯 Benefits:
- Prevents future orphaned lending data
- Maintains data integrity between reader registry and lending records
- Cleanup-friendly for existing orphaned data
- Pure event sourced solution (no external dependencies)

---