## Implement Idempotency and Business Error Handling
- **Created**: 2025-08-19 04:45
- **Priority**: Critical
- **Objective**: Force proper idempotency patterns and comprehensive business error handling across all command handlers for production-ready EventStore reliability

## Problem Description

Current command handlers may not properly handle critical production scenarios:
- **Duplicate command execution** (idempotency failures)
- **Comprehensive business rule validation** with proper error events
- **Edge case error scenarios** that could occur in production
- **Command replay safety** during system recovery

This is critical for production EventStore reliability and proper event sourcing patterns.

## Solution Overview

Implement systematic idempotency and comprehensive business error handling across all command handlers, ensuring the EventStore implementation is production-ready and follows industry best practices.

## Implementation Plan

### Phase 1: Idempotency Infrastructure

#### Command Correlation System
1. **Add correlation IDs to all commands**:
   ```go
   type BaseCommand struct {
       CorrelationID uuid.UUID `json:"correlation_id"`
       CommandID     uuid.UUID `json:"command_id"`
       Timestamp     time.Time `json:"timestamp"`
   }
   ```

2. **Implement command deduplication**:
   ```go
   // In each command handler's Handle() method
   func (h *CommandHandler) Handle(ctx context.Context, cmd Command) error {
       // Check if command already processed
       if h.commandStore.IsProcessed(cmd.CommandID) {
           return h.getIdempotentResult(cmd.CommandID)
       }
       
       // Process command and store result
       result := h.processCommand(ctx, cmd)
       h.commandStore.StoreResult(cmd.CommandID, result)
       return result
   }
   ```

3. **Command store implementation**:
   ```go
   type CommandStore interface {
       IsProcessed(commandID uuid.UUID) bool
       StoreResult(commandID uuid.UUID, result error) 
       GetResult(commandID uuid.UUID) error
   }
   ```

#### Idempotency Testing
1. **Create idempotency test utilities**:
   ```go
   func TestCommandIdempotency(t *testing.T, handler CommandHandler, cmd Command) {
       // Execute command twice with same CommandID
       result1 := handler.Handle(ctx, cmd)
       result2 := handler.Handle(ctx, cmd) 
       
       // Results must be identical
       assert.Equal(t, result1, result2)
       
       // Events should only be appended once
       assertEventCountUnchanged()
   }
   ```

### Phase 2: Comprehensive Business Error Scenarios

#### Error Event Patterns
1. **Standardize failure domain events**:
   ```go
   // Add to example/shared/core/
   type BookLendingFailed struct {
       BookID      uuid.UUID
       ReaderID    uuid.UUID
       AttemptTime time.Time
       Reason      string
       ErrorCode   string
   }
   
   type BookReturnFailed struct {
       BookID      uuid.UUID  
       ReaderID    uuid.UUID
       AttemptTime time.Time
       Reason      string
       ErrorCode   string
   }
   
   type ReaderRegistrationRejected struct {
       ReaderID    uuid.UUID
       AttemptTime time.Time
       Reason      string
       ErrorCode   string
   }
   ```

#### Force Edge Case Handling
1. **Lending scenarios to force**:
   ```go
   // Business rule violations that must generate proper failure events
   - LendBook to non-existent book → BookLendingFailed
   - LendBook to book already lent → BookLendingFailed  
   - LendBook to canceled reader → BookLendingFailed
   - LendBook to non-existent reader → BookLendingFailed
   - LendBook when book not in circulation → BookLendingFailed
   ```

2. **Return scenarios to force**:
   ```go
   - ReturnBook never lent → BookReturnFailed
   - ReturnBook by wrong reader → BookReturnFailed
   - ReturnBook non-existent book → BookReturnFailed
   - ReturnBook by canceled reader → BookReturnFailed
   ```

3. **Registration scenarios to force**:
   ```go
   - RegisterReader with duplicate ID → ReaderRegistrationRejected
   - RegisterReader with invalid data → ReaderRegistrationRejected
   - CancelReader never registered → ReaderCancellationFailed
   ```

### Phase 3: Enhanced Command Handler Validation

#### Systematic Validation Implementation
1. **Create validation framework**:
   ```go
   type ValidationResult struct {
       IsValid      bool
       ErrorCode    string
       ErrorMessage string
       FailureEvent DomainEvent
   }
   
   type CommandValidator interface {
       ValidateCommand(ctx context.Context, cmd Command, currentState State) ValidationResult
   }
   ```

2. **Implement validators for each command**:
   ```go
   // Example: LendBookCopyValidator
   func (v *LendBookCopyValidator) ValidateCommand(ctx context.Context, cmd Command, state State) ValidationResult {
       // Check book exists
       if !state.BookExists(cmd.BookID) {
           return ValidationResult{
               IsValid: false,
               ErrorCode: "BOOK_NOT_FOUND", 
               ErrorMessage: "Book does not exist",
               FailureEvent: BookLendingFailed{...}
           }
       }
       
       // Check book is in circulation
       if !state.BookInCirculation(cmd.BookID) {
           return ValidationResult{
               IsValid: false,
               ErrorCode: "BOOK_NOT_IN_CIRCULATION",
               ErrorMessage: "Book not available for lending", 
               FailureEvent: BookLendingFailed{...}
           }
       }
       
       // Check book is available (not already lent)
       if state.BookIsLent(cmd.BookID) {
           return ValidationResult{
               IsValid: false,
               ErrorCode: "BOOK_ALREADY_LENT",
               ErrorMessage: "Book is currently lent to another reader",
               FailureEvent: BookLendingFailed{...}
           }
       }
       
       // Check reader exists and is active
       if !state.ReaderExistsAndActive(cmd.ReaderID) {
           return ValidationResult{
               IsValid: false, 
               ErrorCode: "READER_NOT_ACTIVE",
               ErrorMessage: "Reader is not registered or has been canceled",
               FailureEvent: BookLendingFailed{...}
           }
       }
       
       return ValidationResult{IsValid: true}
   }
   ```

### Phase 4: Integration Testing & Validation

#### Comprehensive Error Scenario Tests
1. **Create error scenario test suite**:
   ```go
   func TestAllBusinessRuleViolations(t *testing.T) {
       scenarios := []ErrorScenario{
           {
               Name: "Lend non-existent book",
               Setup: func() Command { return LendBookCommand{BookID: nonExistentID, ...} },
               ExpectedErrorCode: "BOOK_NOT_FOUND",
               ExpectedFailureEvent: BookLendingFailed{...},
           },
           {
               Name: "Lend already lent book", 
               Setup: func() Command { 
                   // Pre-lend the book, then try to lend again
                   return LendBookCommand{BookID: alreadyLentID, ...}
               },
               ExpectedErrorCode: "BOOK_ALREADY_LENT",
               ExpectedFailureEvent: BookLendingFailed{...},
           },
           // ... 20+ more scenarios covering every edge case
       }
       
       for _, scenario := range scenarios {
           t.Run(scenario.Name, func(t *testing.T) {
               cmd := scenario.Setup()
               result := handler.Handle(ctx, cmd)
               
               // Verify proper error handling
               assert.Error(t, result)
               assert.Contains(t, result.Error(), scenario.ExpectedErrorCode)
               
               // Verify failure event was generated
               events := eventStore.GetEvents(...)
               assertContainsEvent(t, events, scenario.ExpectedFailureEvent)
           })
       }
   }
   ```

#### Idempotency Integration Tests  
1. **Test idempotency across all handlers**:
   ```go
   func TestAllCommandsAreIdempotent(t *testing.T) {
       commands := []Command{
           LendBookCommand{...},
           ReturnBookCommand{...}, 
           RegisterReaderCommand{...},
           // ... all command types
       }
       
       for _, cmd := range commands {
           t.Run(reflect.TypeOf(cmd).Name(), func(t *testing.T) {
               TestCommandIdempotency(t, getHandlerFor(cmd), cmd)
           })
       }
   }
   ```

#### Concurrent Operation Tests
1. **Test race condition handling**:
   ```go
   func TestConcurrentBookLending(t *testing.T) {
       // Multiple readers try to lend same book simultaneously
       bookID := setupAvailableBook()
       
       var wg sync.WaitGroup
       results := make(chan error, 10)
       
       // Start 10 concurrent lending attempts
       for i := 0; i < 10; i++ {
           wg.Add(1)
           go func(readerNum int) {
               defer wg.Done()
               cmd := LendBookCommand{
                   BookID: bookID,
                   ReaderID: uuid.New(),
                   CommandID: uuid.New(), // Unique command IDs
               }
               err := handler.Handle(ctx, cmd)
               results <- err
           }(i)
       }
       
       wg.Wait()
       close(results)
       
       // Exactly 1 should succeed, 9 should fail with proper error events
       successCount := 0
       failureCount := 0
       for result := range results {
           if result == nil {
               successCount++
           } else {
               failureCount++ 
               assert.Contains(t, result.Error(), "BOOK_ALREADY_LENT")
           }
       }
       
       assert.Equal(t, 1, successCount)
       assert.Equal(t, 9, failureCount)
   }
   ```

## Technical Implementation Details

### Files to Create
```
eventstore/idempotency/
├── command_store.go          # Command deduplication interface
├── memory_command_store.go   # In-memory implementation for testing  
├── postgres_command_store.go # PostgreSQL implementation for production

testutil/idempotency/
├── idempotency_test_helpers.go # Utilities for testing idempotency
├── error_scenario_helpers.go   # Utilities for testing error scenarios

example/shared/validation/
├── command_validator.go      # Validation framework interfaces
├── lending_validator.go      # Book lending validation logic  
├── reader_validator.go       # Reader command validation logic
```

### Files to Modify
**All command handlers** in `example/features/command/*/`:
- Add idempotency checks
- Add comprehensive validation  
- Generate proper failure events
- Return proper error results

**Domain events** in `example/shared/core/`:
- Add failure event types
- Standardize error codes and messages

**Test files**: 
- Add idempotency test coverage
- Add error scenario test coverage
- Add concurrent operation test coverage

### Database Schema Extensions
```sql
-- Command deduplication table
CREATE TABLE command_log (
    command_id UUID PRIMARY KEY,
    correlation_id UUID NOT NULL,
    command_type VARCHAR(255) NOT NULL, 
    processed_at TIMESTAMP NOT NULL,
    result_error TEXT, -- NULL for success, error message for failure
    INDEX idx_correlation_id (correlation_id),
    INDEX idx_processed_at (processed_at)
);
```

## Success Criteria

### Idempotency Requirements
- ✅ All command handlers are idempotent (safe to retry/replay)
- ✅ Duplicate command execution returns identical results
- ✅ No duplicate events are generated for duplicate commands
- ✅ Command correlation and deduplication system implemented
- ✅ Comprehensive idempotency test coverage

### Business Error Handling Requirements  
- ✅ Every possible business rule violation generates proper failure events
- ✅ All error scenarios have standardized error codes and messages
- ✅ Comprehensive error scenario test coverage (20+ edge cases)
- ✅ Proper error event audit trail for debugging
- ✅ Command handlers return proper error results for business rule violations

### Production Readiness Requirements
- ✅ Race condition handling for concurrent operations
- ✅ Performance testing under high concurrent load
- ✅ Error recovery and replay safety validation
- ✅ Monitoring and alerting for command processing failures
- ✅ Documentation of all error scenarios and recovery procedures

## Long-term Impact

### EventStore Reliability
- Production-ready command processing with proper error handling
- Bulletproof idempotency for reliable system operation
- Comprehensive audit trail of all business rule violations

### Development Quality
- Systematic approach to error handling across all features
- Reusable validation and idempotency frameworks
- High-quality test coverage patterns for future development

### Operational Excellence  
- Clear error codes and messages for troubleshooting
- Reliable system behavior under edge conditions
- Proper event sourcing patterns following industry best practices

This implementation will transform the EventStore example from a demonstration to a production-ready system with enterprise-grade reliability and error handling.