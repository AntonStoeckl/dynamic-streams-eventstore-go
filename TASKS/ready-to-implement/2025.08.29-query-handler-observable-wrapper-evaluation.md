## Query Handler Observable Wrapper Implementation Plan
- **Created**: 2025-08-29 16:45
- **Priority**: High
- **Objective**: Implement observable wrapper for query handlers with minimal metadata pattern

## üéØ Problem & Solution

**Problem**: Query handlers have inline observability mixed with business logic (unlike command handlers which use clean wrapper pattern).

**Key Insight**: We already accept returning extra metadata for observability in command handlers (`HandlerResult` with retry info). Same approach works for queries.

**Solution**: QueryMetadata pattern - minimal data passed from core handler to wrapper.

## üìê Architecture Design

### Core Types

```go
// Minimal metadata for observability communication
type QueryMetadata struct {
    SnapshotHit bool  // Only field needed for metrics
}

// Unified interface for ALL query handlers (core, snapshot, observable)
type QueryHandler[Q Query, R any] interface {
    Handle(ctx context.Context, query Q) (R, QueryMetadata, error)
}
```

### Plain Query Handler Implementation

```go
func (h CoreBooksInCirculationHandler) Handle(ctx context.Context, query Query) (BooksInCirculation, QueryMetadata, error) {
    // PURE business logic - no timing, no observability
    storableEvents, maxSeq, err := h.eventStore.Query(ctx, filter)
    if err != nil {
        return BooksInCirculation{}, QueryMetadata{}, err
    }
    
    history, err := shell.DomainEventsFrom(storableEvents)
    if err != nil {
        return BooksInCirculation{}, QueryMetadata{}, err
    }
    
    result := Project(history, query, maxSeq)
    
    // Return result with minimal metadata
    return result, QueryMetadata{SnapshotHit: false}, nil
}
```

### Snapshot Wrapper Implementation

```go
func (w SnapshotWrapper[Q, R]) Handle(ctx context.Context, query Q) (R, QueryMetadata, error) {
    snapshot, err := w.loadSnapshot(ctx, query)
    if err != nil || snapshot == nil {
        // Snapshot miss - fallback to base handler
        result, metadata, err := w.baseHandler.Handle(ctx, query)
        if err == nil {
            go w.saveSnapshot(ctx, result)  // Async save for next time
        }
        return result, metadata, err  // Metadata already has SnapshotHit: false
    }
    
    // Snapshot hit - do incremental update
    incrementalEvents := w.queryIncrementalEvents(ctx, snapshot.SequenceNumber)
    result := w.applyIncrementalUpdates(snapshot, incrementalEvents)
    
    go w.saveSnapshot(ctx, result)  // Update snapshot async
    
    return result, QueryMetadata{SnapshotHit: true}, nil
}
```

### Observable Wrapper Implementation

```go
type ObservableQueryWrapper[Q Query, R any] struct {
    coreHandler      QueryHandler[Q, R]  // Can wrap core handler OR snapshot wrapper
    metricsCollector MetricsCollector
    tracingCollector TracingCollector
    logger           Logger
}

// ObservableQueryWrapper implements the unified QueryHandler interface
func (w ObservableQueryWrapper[Q, R]) Handle(ctx context.Context, query Q) (R, QueryMetadata, error) {
    // Start observability
    start := time.Now()
    ctx, span := StartQuerySpan(ctx, w.tracingCollector, query.QueryType())
    defer span.End()
    
    // Call wrapped handler (core or snapshot)
    result, metadata, err := w.coreHandler.Handle(ctx, query)
    
    // Record metrics using metadata
    duration := time.Since(start)
    if err != nil {
        w.recordQueryError(ctx, query.QueryType(), err, duration)
        return result, metadata, err
    }
    
    // Record success with snapshot status
    labels := map[string]string{
        "query_type": query.QueryType(),
        "snapshot": fmt.Sprintf("%t", metadata.SnapshotHit),
    }
    w.metricsCollector.RecordDuration("query_handler_duration_seconds", duration, labels)
    
    return result, metadata, nil  // Pass through metadata to caller
}
```

## üßπ Cleanup Actions

### 1. Remove Component-Level Metrics from Snapshot Wrapper
- **Delete**: `recordComponentTiming` method
- **Delete**: All `Component*` constants (ComponentSnapshotLoad, ComponentIncrementalQuery, etc.)
- **Delete**: Component timing calls throughout snapshot wrapper
- **Keep**: Only snapshot save duration tracking (internal)

### 2. Simplify Snapshot Wrapper Observability
- **Remove**: Dependency extraction (`baseHandler.ExposeMetricsCollector()`)
- **Remove**: All inline observability from snapshot wrapper
- **Add**: Simple internal metrics for save duration only
- **Communicate**: Hit/miss via QueryMetadata return value

### 3. Refactor All Handlers to Unified Pattern
- **Unified signature**: All handlers return `(R, QueryMetadata, error)`
- **Extract**: Business logic from current handlers (remove observability)
- **Update callers**: Use `result, _, err := handler.Handle(...)` if metadata not needed
- **Keep**: Functional options for backwards compatibility

## üìä Metrics Simplification

### Before (Too Complex)
```
query_handler_component_duration_seconds{component="snapshot_load", ...}
query_handler_component_duration_seconds{component="incremental_query", ...}
query_handler_component_duration_seconds{component="deserialize", ...}
query_handler_component_duration_seconds{component="unmarshal", ...}
query_handler_component_duration_seconds{component="project", ...}
query_handler_component_duration_seconds{component="snapshot_save", ...}
```

### After (Simple & Useful)
```
query_handler_duration_seconds{query_type="books_in_circulation", snapshot="false"}
query_handler_duration_seconds{query_type="books_in_circulation", snapshot="true"}
snapshot_save_duration_seconds{query_type="books_in_circulation"}
```

## üìã Implementation Steps

### Phase 1: Proof of Concept
1. **Define QueryMetadata type** in shell package
2. **Pick one query handler** (booksincirculation) for prototype
3. **Extract core handler** with pure business logic
4. **Create ObservableQueryWrapper** generic type
5. **Test with both plain and snapshot scenarios**

### Phase 2: Snapshot Wrapper Cleanup
1. **Remove component metrics** from snapshot wrapper
2. **Update to return QueryMetadata**
3. **Remove dependency extraction** pattern
4. **Simplify to only track save duration**

### Phase 3: Rollout
1. **Apply pattern to all 7 query handlers**
2. **Update all tests** to use new structure
3. **Remove Expose* methods** from interfaces
4. **Update integration points** (simulation, etc.)

### Phase 4: Verification
1. **Run all tests** to ensure functionality
2. **Check metrics** are being recorded correctly
3. **Verify snapshot hit/miss rates** 
4. **Performance testing** to ensure no regression

## ‚úÖ Success Criteria

- **Pure handlers**: Zero observability code in core handlers
- **Minimal metadata**: Only SnapshotHit flag passed
- **Clean tests**: Can test business logic without mocks
- **Simplified metrics**: Only duration + snapshot status
- **Consistent pattern**: Matches command handler approach
- **Working snapshots**: Hit/miss tracking still works

## üéØ Benefits

1. **Unified Interface**: All handlers have identical `(R, QueryMetadata, error)` signature
2. **Interchangeable**: Callers don't need to know if handler is core, snapshot, or observable
3. **Consistency**: Mirrors command handler pattern (HandlerResult ‚Üî QueryMetadata)
4. **Testability**: Pure business logic without observability
5. **Simplicity**: Removed unnecessary component metrics
6. **Explicit**: Metadata flow is visible (not hidden in wrappers or contexts)
7. **Ignorable**: Callers can use `_` to ignore metadata if not needed