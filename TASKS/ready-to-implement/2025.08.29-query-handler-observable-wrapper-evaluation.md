## Query Handler Observable Wrapper Evaluation
- **Created**: 2025-08-29 16:45
- **Priority**: Medium
- **Objective**: Evaluate if/how query handlers can be wrapped with an observable wrapper instead of having inline observability

## 🎯 Problem Statement

**Current State**: Query handlers have **inline observability** mixed with business logic, similar to what command handlers had before refactoring.

**Question**: Should query handlers also be refactored to use the **external observable wrapper pattern** like command handlers?

## 🔍 Current Query Handler Architecture

**Inline Observability Pattern:**
```go
func (h QueryHandler) Handle(ctx context.Context, query Query) (Result, error) {
    // Metrics, tracing, logging mixed with business logic
    h.metricsCollector.Record("query_duration", ...)
    span := h.tracingCollector.StartSpan(...)
    defer span.End()
    
    // Business logic: Query → Unmarshal → Project
    events, _, err := h.eventStore.Query(ctx, filter)
    // ... business logic ...
    
    h.logger.Info("query completed")
    return result, nil
}
```

**Potential Wrapper Pattern:**
```go
// Pure business logic
func (h CoreQueryHandler) Handle(ctx context.Context, query Query) (Result, error) {
    // ONLY: Query → Unmarshal → Project
    events, _, err := h.eventStore.Query(ctx, filter)
    // ... pure business logic ...
    return result, nil
}

// External wrapper
observableQueryHandler := observable.NewQueryWrapper(
    coreHandler,
    observable.WithMetrics(metricsCollector),
    observable.WithTracing(tracingCollector),
)
```

## 🤔 Evaluation Criteria

### **Arguments FOR Query Handler Wrappers:**

1. **Architectural Consistency**
   - Same pattern as command handlers
   - Consistent separation of concerns across all handlers

2. **Code Reduction**  
   - Move ~50% of observability code to shared wrapper
   - Cleaner query handler business logic

3. **Testing Benefits**
   - Test pure query logic without observability complexity
   - Consistent testing patterns with command handlers

4. **Maintainability**
   - Single place to maintain query observability logic
   - Easier to add/remove observability features

### **Arguments AGAINST Query Handler Wrappers:**

1. **Complexity vs. Benefit Trade-off**
   - Query handlers are simpler than command handlers (no retry logic, simpler workflows)
   - Less observability code to extract compared to command handlers

2. **Current Inline Pattern Works**
   - Query handlers already have clean functional options pattern
   - Observability is well-separated using dependency injection

3. **Testing Strategy**
   - Current approach: Use spies in snapshot tests, no obs in regular tests
   - May be sufficient without additional wrapper complexity

4. **Implementation Effort**
   - Would require refactoring 7 query handler packages
   - May not provide proportional benefits to command handler refactoring

## 📋 Investigation Tasks

### **Phase 1: Analysis**
1. **Measure Current Observability Code**
   - Count lines of observability code vs. business logic in query handlers
   - Compare to command handler improvement (was 60% reduction)
   - Assess if similar benefits would apply to query handlers

2. **Review Current Query Handler Patterns**
   - Analyze existing functional options pattern
   - Check if current separation is already sufficient
   - Identify any pain points with current approach

3. **Testing Impact Assessment**
   - Evaluate current testing strategy effectiveness
   - Determine if wrapper pattern would improve test clarity
   - Consider snapshot test requirements (need observability spies)

### **Phase 2: Prototype (If Analysis Supports It)**
1. **Create Query Observable Wrapper**
   - Design generic `QueryWrapper[Q Query, R Result]` 
   - Extract observability from one query handler as proof of concept
   - Maintain compatibility with existing functional options

2. **Test Integration**
   - Ensure snapshot tests still work with wrapper + spies
   - Verify regular tests work with pure handlers
   - Compare test complexity before/after

### **Phase 3: Decision & Implementation (If Prototype Succeeds)**
1. **Go/No-Go Decision**
   - Evaluate benefits vs. complexity
   - Consider maintenance burden vs. consistency gains
   - Make architectural decision

2. **Rollout (If Approved)**
   - Refactor remaining 6 query handler packages
   - Update all tests
   - Update documentation

## 🎯 Success Criteria

**Decision Criteria:**
- Clear benefits outweigh implementation complexity
- Maintains or improves test clarity
- Provides meaningful code reduction (>30%)
- Aligns with overall architectural goals

**Implementation Success (If Approved):**
- All query handlers refactored with consistent pattern
- All tests pass with new architecture
- Documentation updated
- 0 linting issues

## 📝 Considerations

**Architectural Philosophy:**
- **Consistency**: Same patterns across all handlers
- **Pragmatism**: Don't over-engineer if current solution works well
- **Maintainability**: Consider long-term maintenance burden

**Current Status:**
- Command handlers: ✅ External wrapper pattern implemented
- Query handlers: ❓ Inline observability - evaluate if change needed

## 🚦 Next Steps

1. **Start with Phase 1 Analysis** to determine if wrapper pattern would provide meaningful benefits
2. **Make data-driven decision** based on code analysis and complexity assessment
3. **Consider user/team preferences** for consistency vs. pragmatism
4. **Document decision** regardless of outcome for future reference

---

**Note**: This evaluation should be thorough but pragmatic. The goal is to make the best architectural decision, whether that's implementing wrappers for consistency or keeping the current pattern if it's already working well.