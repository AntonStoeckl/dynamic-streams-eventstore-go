## Query Handler Observable Wrapper Implementation Plan
- **Created**: 2025-08-29 16:45
- **Priority**: High
- **Objective**: Implement observable wrapper for query handlers with minimal metadata pattern

## üéØ Problem & Solution

**Problem**: Query handlers have inline observability mixed with business logic (unlike command handlers which use clean wrapper pattern).

**Initial Approach**: QueryMetadata pattern (like HandlerResult for commands).

**Simplified Solution**: After analysis, QueryMetadata is unnecessary! The observable wrapper already has everything it needs:
- Query execution duration
- Success/error status  
- Query type from the Query object

No metadata passing needed - just clean separation of concerns.

## üìê Simplified Architecture Design (No QueryMetadata Needed!)

### Core Query Handler Implementation

```go
// Pure business logic handler - no observability
type CoreBooksInCirculationHandler struct {
    eventStore shell.QueriesEvents
}

func (h CoreBooksInCirculationHandler) Handle(ctx context.Context, query Query) (BooksInCirculation, error) {
    // PURE business logic - no timing, no observability
    filter := BuildEventFilter()
    ctx = eventstore.WithEventualConsistency(ctx)
    
    storableEvents, maxSeq, err := h.eventStore.Query(ctx, filter)
    if err != nil {
        return BooksInCirculation{}, err
    }
    
    history, err := shell.DomainEventsFrom(storableEvents)
    if err != nil {
        return BooksInCirculation{}, err
    }
    
    result := Project(history, query, maxSeq)
    return result, nil
}
```

### Observable Wrapper Implementation

```go
type ObservableQueryWrapper[Q Query, R any] struct {
    coreHandler      QueryHandler[Q, R]  // Wraps any handler
    queryType        string
    metricsCollector MetricsCollector
    tracingCollector TracingCollector
    logger           Logger
}

func (w ObservableQueryWrapper[Q, R]) Handle(ctx context.Context, query Q) (R, error) {
    // Start observability
    start := time.Now()
    ctx, span := StartQuerySpan(ctx, w.tracingCollector, w.queryType)
    LogQueryStart(ctx, w.logger, w.queryType)
    
    // Call wrapped handler (core or snapshot)
    result, err := w.coreHandler.Handle(ctx, query)
    
    // Record metrics - no metadata needed!
    duration := time.Since(start)
    if err != nil {
        w.recordQueryError(ctx, err, duration, span)
        return result, err
    }
    
    w.recordQuerySuccess(ctx, duration, span)
    return result, nil
}
```

### Snapshot Wrapper Stays Simple

```go
func (w SnapshotWrapper[Q, R]) Handle(ctx context.Context, query Q) (R, error) {
    snapshot, err := w.loadSnapshot(ctx, query)
    if err != nil || snapshot == nil {
        // Snapshot miss - fallback to base handler
        result, err := w.baseHandler.Handle(ctx, query)
        if err == nil {
            go w.saveSnapshot(ctx, result)  // Async save
        }
        return result, err
    }
    
    // Snapshot hit - do incremental update
    incrementalEvents := w.queryIncrementalEvents(ctx, snapshot.SequenceNumber)
    result := w.applyIncrementalUpdates(snapshot, incrementalEvents)
    
    go w.saveSnapshot(ctx, result)  // Update snapshot async
    return result, nil
}
```

## üßπ Cleanup Actions

### 1. Remove ALL Component-Level Metrics from Snapshot Wrapper
- **Delete**: `recordComponentTiming` method
- **Delete**: All `Component*` constants (ComponentSnapshotLoad, ComponentIncrementalQuery, etc.)
- **Delete**: ALL component timing calls throughout snapshot wrapper
- **Remove**: ALL metrics recording from snapshot wrapper (Option A)

### 2. Simplify Snapshot Wrapper Completely
- **Remove**: Dependency extraction (`baseHandler.ExposeMetricsCollector()`)
- **Remove**: ALL observability from snapshot wrapper
- **Keep**: Only logging for debugging (hit/miss info)
- **No metrics**: Snapshot metrics will be added to EventStore later (separate task)

### 3. Refactor All Handlers to Simple Pattern
- **Simple signature**: All handlers return just `(R, error)` - no metadata!
- **Extract**: Business logic from current handlers (remove observability)
- **Keep**: Functional options for backwards compatibility

## üìä Metrics Simplification

### Before (Too Complex)
```
query_handler_component_duration_seconds{component="snapshot_load", ...}
query_handler_component_duration_seconds{component="incremental_query", ...}
query_handler_component_duration_seconds{component="deserialize", ...}
query_handler_component_duration_seconds{component="unmarshal", ...}
query_handler_component_duration_seconds{component="project", ...}
query_handler_component_duration_seconds{component="snapshot_save", ...}
```

### After (Clean & Simple)
```
query_handler_duration_seconds{query_type="books_in_circulation"}
// That's it! No snapshot metrics at wrapper level
// Future: eventstore_snapshot_save_duration_seconds (in EventStore)
// Future: eventstore_snapshot_load_duration_seconds (in EventStore)
```

## üìã Implementation Steps (Simplified!)

### Phase 1: Snapshot Wrapper Cleanup (START HERE - Isolated & Safe)
1. **Remove ALL component metrics** from snapshot wrapper:
   - Delete `recordComponentTiming()` method
   - Remove ALL component timing calls
   - Remove ALL metrics recording (no internal metrics either)
2. **Clean up Grafana dashboard** (`library-example-dashboard.json`):
   - Remove the snapshot save duration panel entirely
   - Clean up any references to component metrics
3. **Simplify snapshot wrapper**:
   - Remove ALL metrics dependencies
   - Keep only logging for debugging
4. **Clean up constants** in `observability.go`:
   - Remove ALL `Component*` constants
   - Remove `QueryHandlerComponentDurationMetric` constant
5. **Run tests** to ensure nothing breaks

### Phase 2: Proof of Concept (Simpler without metadata!)
1. **Pick one query handler** (booksincirculation) for prototype
2. **Extract core handler** with pure business logic - returns `(R, error)`
3. **Create ObservableQueryWrapper** generic type
4. **Test with both plain and snapshot scenarios**

### Phase 3: Rollout
1. **Apply pattern to all 7 query handlers**
2. **Update all tests** to use new structure
3. **Remove Expose* methods** from interfaces
4. **Update simulation bootstrapping** in `simulation2/handlers.go`:
   - Change from: `NewQueryHandler(eventStore, WithMetrics(...), WithTracing(...)` wrapped by snapshot
   - To: `NewCoreQueryHandler(eventStore)` ‚Üí `SnapshotWrapper` ‚Üí `ObservableWrapper`
   - Correct composition order: **Core ‚Üí Snapshot (optional) ‚Üí Observable**
   - Remove `buildBooksInCirculationOptions()` and similar functions
   - Update all query handler instantiations

### Phase 4: Final Verification
1. **Run all tests** to ensure functionality
2. **Check metrics** are being recorded correctly
3. **Performance testing** to ensure no regression

## ‚úÖ Success Criteria

- **Pure handlers**: Zero observability code in core handlers
- **No metadata needed**: Simple `(R, error)` signature
- **Clean tests**: Can test business logic without mocks
- **Simplified metrics**: Only query duration at wrapper level
- **Consistent pattern**: Matches command handler wrapper approach
- **Working snapshots**: Still functional, just without metrics

## üéØ Benefits

1. **Simplest possible interface**: All handlers have identical `(R, error)` signature
2. **Fully interchangeable**: Core, snapshot, and observable wrappers all have same interface
3. **Maximum simplicity**: No metadata passing, no complexity
4. **Perfect testability**: Pure business logic without any infrastructure
5. **Cleaner codebase**: Removed 6 complex component metrics
6. **Future-proof**: EventStore snapshots metrics can be added independently