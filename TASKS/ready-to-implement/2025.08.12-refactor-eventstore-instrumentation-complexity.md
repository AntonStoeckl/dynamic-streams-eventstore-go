## Refactor EventStore Instrumentation to Reduce Method Complexity

- **Created**: 2025-08-12 15:06
- **Priority**: Medium
- **Objective**: Extract extensive observability instrumentation from Query() and Append() methods to improve code maintainability and address linter warnings

### Problem Statement

The comprehensive 3-level metrics instrumentation (method-level, SQL-level, and component-level timing) has significantly increased the complexity of the core EventStore methods:

- `Query()` method: ~50+ statements (linter limit: 40)
- `Append()` method: ~47+ statements (linter limit: 40)

The instrumentation code now overshadows the actual business logic, making the methods harder to read, understand, and maintain.

### Current Instrumentation Architecture

```go
func (es *EventStore) Query() {
    // Method-level timing start
    methodStart := time.Now()
    
    // Tracing and metrics setup
    tracer, ctx := es.startQueryTracing(ctx)
    metrics := es.startQueryMetrics(ctx)
    
    // Component timing: Query building
    queryBuildStart := time.Now()
    sqlQuery, err := es.buildSelectQuery(filter)
    queryBuildDuration := time.Since(queryBuildStart)
    metrics.recordComponentSuccess(componentQueryBuild, queryBuildDuration)
    
    // Component timing: SQL execution
    rows, sqlDuration, err := es.executeQuery(ctx, sqlQuery)
    metrics.recordComponentSuccess(componentSQLExecution, sqlDuration)
    
    // Component timing: Result processing
    resultProcessStart := time.Now()
    eventStream, maxSeq, err := es.processQueryResults(rows, metrics)
    resultProcessDuration := time.Since(resultProcessStart)
    metrics.recordComponentSuccess(componentResultProcessing, resultProcessDuration)
    
    // Method completion timing and recording
    methodDuration := time.Since(methodStart)
    metrics.recordSuccess(eventStream, sqlDuration)        // SQL-level
    metrics.recordMethodSuccess(eventStream, methodDuration) // Method-level
    
    // Error handling with timing for all failure paths...
}
```

### Goal

Reduce method complexity while preserving:
- ✅ All existing metrics (method-level, SQL-level, component-level)
- ✅ All error handling and timing accuracy
- ✅ All tracing and logging functionality
- ✅ Backward compatibility with existing observability consumers

### Potential Solutions

#### Option 1: Instrumentation Helper Methods
Extract timing logic into dedicated helper methods:
```go
func (es *EventStore) Query() {
    return es.instrumentedQuery(ctx, filter, es.coreQueryLogic)
}

func (es *EventStore) coreQueryLogic(ctx, filter) {
    // Pure business logic without instrumentation
}
```

#### Option 2: Decorator Pattern
Wrap core business logic with instrumentation decorators:
```go
type InstrumentedEventStore struct {
    core EventStore
    instrumentation *ObservabilityInstrumentation
}

func (ies *InstrumentedEventStore) Query() {
    return ies.instrumentation.WrapQuery(ies.core.Query)
}
```

#### Option 3: Interceptor Pattern
Create middleware-style instrumentation interceptors:
```go
func (es *EventStore) Query() {
    interceptors := []QueryInterceptor{
        es.timingInterceptor,
        es.metricsInterceptor, 
        es.tracingInterceptor,
    }
    return es.executeWithInterceptors(interceptors, es.coreQuery)
}
```

#### Option 4: Observer Chain Pattern
Use observer pattern to decouple instrumentation:
```go
func (es *EventStore) Query() {
    execution := &QueryExecution{/*...*/}
    es.notifyObservers(QueryStarted, execution)
    
    result, err := es.coreQuery(ctx, filter)
    
    execution.Result = result
    es.notifyObservers(QueryCompleted, execution)
    return result, err
}
```

### Implementation Considerations

- **Performance**: Ensure refactoring doesn't introduce performance overhead
- **Testing**: All existing observability tests must continue to pass
- **Readability**: Core business logic should become more prominent
- **Maintainability**: Adding new instrumentation should be easier
- **Debugging**: Error cases and timing accuracy must be preserved

### Success Criteria

1. ✅ `Query()` and `Append()` methods under linter statement limits (≤40 statements)
2. ✅ Core business logic is clearly visible and understandable
3. ✅ All existing observability tests pass unchanged
4. ✅ All metrics continue to be recorded with same accuracy
5. ✅ Performance benchmarks show no regression
6. ✅ New instrumentation can be added without modifying core methods

### Notes

This is architectural refactoring that improves code quality without changing functionality. The comprehensive metrics instrumentation we implemented works correctly - this task is about organizing the code better for long-term maintainability.