## Scale Simulation to 100+ req/sec with Time-Compressed Realistic Patterns
- **Created**: 2025-08-13 01:00
- **Priority**: High - Discover EventStore performance limits under realistic workload
- **Objective**: Investigate and optimize simulation to handle 100+ req/sec with time-compressed but realistic library operation patterns

### Current Performance Issue
- **Target Rate**: 60 req/sec configured
- **Actual Rate**: ~37 req/sec achieved (~62% efficiency)
- **Investigation Goal**: Find what prevents higher throughput and push to 100+ req/sec to discover system limits

### Approach: Time Compression + Higher Concurrency
**Key Insight**: 1 simulation second ≠ 1 real-world second. We can compress time to test high-load scenarios that would take hours/days in real life, compressed into minutes for EventStore limit testing.

### Investigation Areas

#### 1. Worker Pool Scaling Analysis
**Current Configuration**:
- **Worker Count**: 50 workers (conservative from previous load generator architecture)
- **Queue Size**: 100 slots (workerCount * 2)
- **Connection Pool**: Aligned with database connection capacity

**Investigation Tasks**:
- Test worker counts: 100, 150, 200+ workers
- Monitor connection pool utilization vs worker count
- Find optimal worker/connection ratio for simulation workload
- Track queue depth and backpressure metrics under load

#### 2. Accelerated Reader Activity Patterns
**Current Scale**: 14,000-15,000 readers, 60,000-65,000 books (Munich library branch scale)
**Current Pattern**: Conservative/realistic borrowing frequencies

**Scaling Opportunities**:
- **Higher Activity Frequency**: Same readers, much more frequent operations (time compression)
- **Concurrent Operations**: More readers active simultaneously (compressed peak hours)
- **Rapid Cycles**: Multiple borrow/return cycles per reader in compressed time
- **Peak Hour Simulation**: Compress normal daily patterns into minutes
- **Proportional Scale-Up**: More readers + proportionally more books (maintain sound book/reader ratio)
  - Current ratio: ~4.5 books per reader (realistic availability)
  - Scaling: Increase both readers and books proportionally (e.g., 20K readers + 90K books)
  - Constraint: Don't scale too extremely - maintain believable library branch proportions

#### 3. State Management Under High Load
**Current Implementation**: SimulationState with mutex protection for concurrent access
**Potential Bottlenecks**:
- State lookup frequency during scenario selection
- Mutex contention with high worker count
- State update operations blocking workers

**Investigation Focus**:
- Profile state access patterns under 100+ req/sec load
- Identify mutex contention points
- Optimize without breaking simulation logic consistency

#### 4. System Limit Discovery Process
**Progressive Testing Approach**:
1. **Baseline**: Current 37 req/sec performance characteristics
2. **Incremental**: Test 60, 80, 100, 120+ req/sec targets
3. **Failure Analysis**: Monitor when errors/backpressure become significant
4. **Bottleneck Identification**: Database, application, or architectural limits

### Implementation Plan

#### Phase 1: Worker Pool Optimization
**Objective**: Find optimal worker count for simulation workload
- **Config Changes**: Increase default worker count (50 → 100, 150, 200)
- **Queue Sizing**: Adjust queue size relative to worker count
- **Connection Alignment**: Ensure worker count doesn't exceed connection pool capacity
- **Monitoring**: Track worker utilization, queue depth, backpressure

#### Phase 2: Reader Activity Acceleration  
**Objective**: Enable higher concurrent activity through time compression
- **Activity Frequency**: Increase reader operation rates (time compression)
- **Concurrent Patterns**: More readers performing operations simultaneously
- **Proportional Scaling**: Test scaling both readers and books (maintain ~4.5 books/reader ratio)
- **Scale Testing**: 20K readers + 90K books, 25K readers + 110K books, etc.
- **Scenario Weights**: Optimize scenario selection for higher throughput
- **Realistic Constraints**: Maintain logical operation patterns and believable proportions

#### Phase 3: Performance Bottleneck Analysis
**Objective**: Identify and resolve limiting factors
- **State Management**: Optimize mutex usage and state access patterns
- **Query Patterns**: Monitor database operation patterns under high load
- **Resource Utilization**: Track CPU, memory, connection pool usage
- **Failure Modes**: Document what breaks first at high rates

#### Phase 4: Limit Discovery and Documentation
**Objective**: Find true EventStore performance limits
- **Progressive Load Testing**: Push to 100+ req/sec until failure
- **Bottleneck Documentation**: What component limits performance first?
- **Scaling Recommendations**: Optimal configurations for different throughput targets
- **Performance Characteristics**: Document behavior under various load levels

### Files to Investigate/Modify
1. **`example/simulation/cmd/config.go`**: 
   - Default worker count configuration
   - Rate limits and throughput settings
   - Queue sizing parameters

2. **`example/simulation/cmd/simulation.go`**:
   - Worker pool architecture
   - Worker count calculation logic
   - Queue management and backpressure handling

3. **`example/simulation/cmd/scenarios.go`**:
   - Reader activity frequency patterns
   - Scenario selection logic under high load
   - Activity rate calculations

4. **`example/simulation/cmd/state.go`**:
   - State management mutex patterns
   - Concurrent access optimization
   - State lookup and update efficiency

### Success Criteria
- **Achieve 80+ req/sec sustained**: Significant improvement over current 37 req/sec
- **Test 100+ req/sec capacity**: Push to system limits and document failure points
- **Maintain Logical Consistency**: Realistic patterns, just time-compressed
- **Document Scaling Limits**: Clear understanding of what component becomes the bottleneck
- **Provide Scaling Guidance**: Optimal configurations for different throughput targets

### Expected Findings
**Potential Bottlenecks to Investigate**:
1. **Worker Pool Saturation**: Fixed worker count limiting concurrent operations
2. **State Management Contention**: Mutex blocking high-frequency state access
3. **Database Connection Limits**: Connection pool capacity vs worker demand
4. **Query Handler Overhead**: Complex realistic queries vs simple operations
5. **EventStore Architecture**: Inherent limits in dynamic consistency boundary operations

### Key Insight: Realistic vs Performance
The simulation should maintain **logical realism** (realistic operation patterns and business rules) while using **time compression** to achieve high load testing. This allows discovery of EventStore limits under realistic workload patterns compressed into test timeframes.

### Performance Analysis Framework
- **Monitor**: Worker utilization, queue depth, backpressure, connection pool usage
- **Measure**: Actual throughput vs target, error rates, latency percentiles
- **Document**: Breaking points, failure modes, optimal configurations
- **Recommend**: Scaling strategies for different performance targets