## Simulation Tuning and Concurrency Error Investigation
- **Created**: 2025-08-19 17:06
- **Started**: 2025-08-19 17:06
- **Priority**: High
- **Objective**: Address concurrency errors and optimize simulation tuning for realistic library behavior

## 🎯 Session Goals

### **Primary Issues Addressed**
1. **Misleading batch timing metrics** (showing 12ms/op vs actual 50-60ms)
2. **Low library activity** (~600 books lent from 60,000 total)
3. **High concurrency error rates** (273 failures: 184 returns, 89 borrows)
4. **Auto-tuning instability** (P50/P99 not correlating with Grafana)

## ✅ Completed Tuning Changes

### **1. Fixed Batch Timing Display**
- **Problem**: Batch logs showed "avg: 12ms/op" but Grafana showed 50-60ms per operation
- **Root Cause**: Batch timing divided total time by operations, creating parallel-diluted averages
- **Solution**: Modified `processReaderBatch()` and `processActiveReaders()` to track individual operation wall-clock times
- **Result**: Batch logs now show accurate 58-73ms/op aligning with Grafana metrics

### **2. Increased Library Activity**
**Circulation Improvements:**
- `ChanceVisitDirectly`: 0.6 → **0.8** (80% direct visits for readers without books)  
- `ChanceBorrowAfterReturn`: 0.5 → **0.7** (70% browse after returning)
- `ChancePreferReadersWithBooks`: 0.6 → **0.5** (balanced reader selection)
- `InitialActiveReaders`: 80 → **150** (more concurrent readers)

**Book Borrowing Volume:**
- `MaxBooksPerVisit`: 2 → **7** (readers can borrow 1-7 books per visit)
- `ChanceReturnAll`: 0.8 → **0.7** (30% keep some books for circulation)
- `ChanceBrowseOnline`: 0.1 → **0.2** (more wishlist creation)
- `OnlineWishlistSize`: 3 → **5** (larger wishlists)

**Result**: Books lent increased from ~600 to **1,500-1,600** (2.5% of collection)

### **3. State Synchronization Fix**
- **Problem**: High return failures (184 errors) suggested state desync
- **Solution**: `StateRefreshIntervalMs`: 2000 → **500** (4x faster state refresh)
- **Rationale**: Actors' view of borrowed books more accurate, reducing phantom returns

### **4. Auto-Tuning Metrics Window Fix**
- **Problem**: `MetricsWindowSize = 500` only captured 6-7 seconds, dropping slow operations
- **Solution**: `MetricsWindowSize`: 500 → **2500** (capture full 30-second timeout window)
- **Impact**: P50/P99 now include slow operations, better auto-tuning decisions

## 🚨 Current Issues Under Investigation

### **Concurrency Error Pattern**
```
184 return failures: "failed to return book: concurrency error, no rows were affected"
89 borrow failures: "failed to borrow book: concurrency error, no rows were affected"
```

**Analysis:**
- **Return failures**: Concerning - suggests actors think they have books they don't
- **Borrow failures**: Expected due to wishlist overlap (multiple readers want same book)
- **Overall**: 75% operation failure rate (100 successful ops with 400 active readers)

### **Potential Root Causes**
1. **State refresh lag**: Even at 500ms, actors may have outdated book ownership
2. **Wishlist collision**: Large wishlists (size 5) cause multiple readers to target same books  
3. **Actor state corruption**: Actors' `BorrowedBooks` list not updating after failures
4. **Race conditions**: High-frequency operations (100ms batch delay) creating conflicts

## 🔧 Current System Performance

### **Activity Metrics**
- **Active readers**: ~400 (auto-scaled from 150)
- **Books circulating**: 1,500-1,600 (2.5% utilization)
- **Operations per batch**: ~100 (low success rate)
- **Batch frequency**: Every 100ms (10 batches/second)

### **Auto-Tuning Targets**
- `TargetP50LatencyMs`: 70ms
- `TargetP99LatencyMs`: 180ms  
- `MaxTimeoutRate`: 0.005 (0.5%)

## 📋 Next Steps for Investigation

### **1. Monitor MetricsWindowSize Impact**
- Check if larger window improves auto-tuning stability
- Verify P50/P99 correlation with Grafana after change

### **2. Analyze Concurrency Error Patterns**
- Determine if return failures decrease with faster state refresh (500ms)
- Investigate actor `BorrowedBooks` synchronization issues

### **3. Consider Additional Tuning**
- Reduce `OnlineWishlistSize` to decrease borrow conflicts
- Implement actor state validation/cleanup
- Add operation failure recovery mechanisms

## 📊 Success Metrics
- **Concurrency errors**: Reduce from 273 to <50 per batch cycle
- **Operation success rate**: Increase from 25% to 75%+
- **Books circulation**: Maintain 1,500+ while reducing conflicts
- **Auto-tuning stability**: Consistent P50/P99 correlation with Grafana

## 🔍 Key Learning
The 4-5x timing discrepancy was a **measurement artifact**, not a performance issue. The EventStore is performing correctly - we were just measuring parallel-diluted averages instead of actual per-operation timing.

## 💡 CRITICAL DISCOVERY: Operation Counting Bug

### **Root Cause Analysis**
After investigating the massive discrepancy between batch logs (8 ops/sec) and Grafana metrics (52 ops/sec), discovered that:

**The batch processor counted each `VisitLibrary()` as 1 operation, but each visit performs MULTIPLE EventStore operations:**
- Return 3 books = 3 `ExecuteReturnBook` calls
- Borrow 2 books = 2 `ExecuteLendBook` calls  
- **Total**: 5 EventStore operations, but batch counted as 1

**This explains:**
- Why batch showed 194 operations in 24s = 8 ops/sec
- But Grafana saw 26 lends + 26 returns = 52 ops/sec actual
- Auto-tuner made bad decisions based on wrong metrics

## ✅ FIXED: Complete Operation Counting Overhaul

### **1. Fixed Batch Timing Unit Display Bug**
**Problem**: `avgOpTime := totalOpTime / time.Duration(len(allOperationDurations))` caused unit confusion
- Result showed "1.01s/op" instead of correct "~100ms/op"
- **Fix**: `avgOpTime := time.Duration(int64(totalOpTime) / int64(len(allOperationDurations)))`

### **2. Updated VisitLibrary Method** (`actors.go`)
**Before**: `func VisitLibrary(ctx, handlers) error`
**After**: `func VisitLibrary(ctx, handlers) (int, error)`
- Now returns actual count of operations performed
- Calls `returnBooks()` and `browseAndBorrow()` which count their operations

### **3. Updated Support Methods** (`actors.go`)
**returnBooks()**: Now returns count of `ExecuteReturnBook` calls
**browseAndBorrow()**: Now returns count of `ExecuteLendBook` calls
- Each method tracks `operationCount++` for every EventStore operation

### **4. Updated Batch Processor** (`scheduler.go`)
**Before**: Counted 1 per successful `VisitLibrary()`
**After**: 
```go
operationCount, err := reader.VisitLibrary(ctx, as.handlers)
// Add timing entries for each actual operation
for i := 0; i < operationCount; i++ {
    result.OperationDurations = append(result.OperationDurations, operationDuration/time.Duration(operationCount))
}
result.OperationCount += operationCount
```

### **5. Updated Librarian Operations** (`actors.go`, `scheduler.go`)
**Before**: Counted 1 per librarian work call
**After**: Count actual `ExecuteAddBook` and `ExecuteRemoveBook` operations
- `addBooks()` and `removeBooks()` return operation counts
- Scheduler properly tracks librarian operation counts

### **6. Query Operations Already Tracked**
- `QueryBooksLentByReader` already records metrics via `recordMetrics()` in handlers
- 10% chance on reader activation (ChanceSyncOnActivation = 0.1)

## 📊 Expected Results
- **Batch rounds**: Will show actual EventStore operation counts (matching Grafana)
- **Auto-tuner**: Will see real throughput instead of 5-6x undercount
- **Metrics alignment**: Simulation logs and Grafana will match
- **Proper scaling**: Auto-tuner decisions based on accurate data

## ✅ FIXED: Batch Processing Pile-up and Wishlist System Issues

### **1. Removed Unrealistic Wishlist System** (`actors.go`, `tuning.go`)
**Problem**: Wishlist concept not realistic for physical library - readers can only borrow books they have in hand
**Changes**:
- Removed `Wishlist []uuid.UUID` field from `ReaderActor` struct
- Removed wishlist-related constants: `ChanceBrowseOnline`, `OnlineWishlistSize`
- Simplified `browseAndBorrow()` to only browse available books physically in library
- Updated `ShouldVisitLibrary()` to use simple direct visit probability
- Readers without books now always browse when visiting (realistic behavior)

### **2. Fixed Batch Processing Pile-up** (`scheduler.go`)
**Problem**: Timer-based batches started every 100ms regardless of completion, causing pile-up
**Solution - Sequential Processing**:
- Replaced ticker-based `processReaderBatches()` with sequential loop
- Added `batchInProgress` flag and `batchMutex` for overlap detection
- Implemented adaptive delays: wait remainder if batch completes <100ms, proceed immediately if >100ms
- Added batch coordination metrics: `BatchesSkipped`, `TotalBatchWaitTime`

### **3. Enhanced Batch Monitoring** (`scheduler.go`)
**Added tracking for**:
- Batches skipped due to overlap (prevents goroutine explosion)
- Total wait time between batches
- Improved batch logging with coordination info

### **4. Realistic Library Behavior**
**After wishlist removal**:
- Readers visit primarily to return books (90% chance if they have books)
- Readers without books visit directly to browse physical books (80% chance)
- In-library browsing simulates walking the aisles and picking books
- No more artificial "online wishlist" coordination issues

## 🔧 Files Modified
- `example/simulation2/actors.go`: Removed wishlist system, simplified browsing
- `example/simulation2/scheduler.go`: Sequential batch processing, overlap detection, enhanced metrics
- `example/simulation2/tuning.go`: Removed wishlist constants
- All changes compiled successfully and pass linting

## 📊 Expected Results
- **No more batch pile-up**: One batch completes before next starts
- **Reduced concurrency errors**: No wishlist conflicts causing "book already lent" 
- **Predictable timing**: Operations complete in predictable sequence
- **Realistic behavior**: Library patrons behave like real people browsing physical books
- **Stable performance**: No degrading operation times due to resource competition